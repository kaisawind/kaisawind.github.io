---
layout: post
title:  "TreeSitter基本语法"
date: 2022-07-08 10:47:54
categories: [编程语言,js]
tags: [js, linux]
excerpt_separator: <!--more-->
---
TreeSitter基本语法
<!--more-->

## 内置函数

* 符号 `$`
    每个语法规则都是一个js函数，函数的参数是`$`。`$.identifier`是规则中的另一个符号。

* 字符串和正则表达式
    终端符号都是用字符串和正则表达式描述。注意底层没有使用js的正则引擎，有自己的正则表达式符号。

* 序列 `seq(rule1, rule2, ...)`
    使用其它规则创建新的有序规则。

* 选择 `choice(rule1, rule2, ...)`
    使用规则列表中的一个创建新的规则。顺序无关。

* 重复 `repeat(rule)`
    将规则重复`0-n`次创建新的规则。

* 重复 `repeat1(rule)`
    将规则重复`1-n`次创建新的规则。

* 可选 `optional(rule)`
    可选规则(`0-1`次)创建新的规则。

* 优先级 `prec(number, rule)`
    指定规则优先级。规则默认优先级为0。当两个规则冲突时，默认使用更高优先级解决。

* 左关联性 `prec.left([number], rule)`
    指定规则为左关联规则。出现相同规则优先级时，优先执行左侧规则。

* 右关联性 `prec.right([number], rule)`
    指定规则为右关联规则。出现相同规则优先级时，优先执行右侧规则。

* 动态优先级 `prec.dynamic(number, rule)`
    优先级在动态运行时有效。动态运行处理语法冲突时，才有必要。

* 符号化 `token(rule)`
    将规则输出的内容标记为单个符号。默认是将字符串或正则标记为单独的符号。本函数可以将复杂表达式，标记为单个符号。

* 立即符号 `token.immediate(rule)`
    只有在前面没有空格时，进行符号化。

* 别名 `alias(rule, name)`
    语法树中以替代名称出现。

* 字段名称 `field(name, rule)`
    将字段名称分配给规则。

## 公共字段


* extras
    可能出现在语言中任何地方的符号数组。

* inline
    一组规则名称，应通过将其所有用法替换为其定义的副本来自动从语法中删除。 这对于在多个地方使用但不想在运行时创建语法树节点的规则很有用。

* conflicts
    规则名称数组的数组。

* externals
    可以由外部扫描器返回的符号名称数组。

* word
    关键字

* supertypes 
    隐藏规则名称的数组，在生成的节点类型文件中应被视为“超类型”。
