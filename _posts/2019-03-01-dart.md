---
layout: post
title:  "dartå¦‚ä½•æœ‰æ•ˆçš„è¿›è¡Œæ•°æ®è½¬æ¢"
date: 2019-3-1 15:01:59 +0800
categories: [dart]
excerpt_separator: <!--more-->
---
åœ¨ä¸åŒçš„æ•°æ®æ ¼å¼ä¹‹é—´è¿›è¡Œè½¬æ¢ï¼Œæ˜¯è®¡ç®—æœºå·¥ç¨‹çš„å¸¸è§„ä½œä¸šã€‚Dartè¯­è¨€ä¹Ÿæ²¡æœ‰ä¾‹å¤–ï¼Œä½¿ç”¨`dart:convert`æ ¸å¿ƒåº“ï¼Œèƒ½å¤Ÿæä¾›ä¸€ç³»åˆ—è½¬æ¢å™¨å’Œæœ‰ç”¨çš„å·¥å…·ç”Ÿæˆæ–°çš„è½¬æ¢å™¨ã€‚åº“å·²ç»æä¾›äº†ä¸€äº›å¸¸ç”¨åˆ°çš„è½¬æ¢ä¾‹å­ï¼Œä¾‹å¦‚ï¼š`JSON`å’Œ`UTF-8`ã€‚åœ¨è¿™ç¯‡æ–‡ç« ä¸­ï¼Œæˆ‘ä»¬å±•ç¤ºäº†Dartçš„è½¬æ¢æ–¹æ³•æ˜¯æ€æ ·å·¥ä½œçš„ï¼Œè¿˜æœ‰åœ¨Dartçš„ä¸–ç•Œä¸­ï¼Œä½ å¯ä»¥æ€æ ·åˆ›å»ºè‡ªå·±é«˜æ•ˆçš„è½¬æ¢å™¨ã€‚
<!--more-->

### å®å›¾

Dartçš„è½¬æ¢æ¶æ„å¸ˆåŸºäº`converters`(è½¬æ¢å™¨)ï¼Œèƒ½å¤Ÿä»ä¸€ç§æ ¼å¼è½¬æ¢ä¸ºå¦ä¸€ç§æ ¼å¼ã€‚å½“è½¬æ¢æ˜¯å¯é€†æ—¶ï¼Œä¸¤ç§è½¬æ¢å™¨èƒ½å¤Ÿè¢«åˆå¹¶åˆ°ä¸€èµ·å½¢æˆ`codec`ï¼ˆç¼–-è§£ç å™¨ï¼‰ã€‚ç¼–è§£ç å™¨é€‚åº”äºéŸ³è§†é¢‘çš„å¤„ç†ï¼Œä½†æ˜¯ä¹Ÿé€‚åº”äºå­—ç¬¦ä¸²ç¼–ç ï¼Œä¾‹å¦‚ï¼š`UTF8`å’Œ`JSON`.

æŒ‰ç…§çº¦å®šï¼ŒDartä¸­ä½¿ç”¨åˆ°çš„æ‰€æœ‰è½¬æ¢å™¨éƒ½éœ€è¦ä½¿ç”¨`dart:convert`ä¸­æä¾›çš„æŠ½è±¡æ–¹æ³•ã€‚è¿™èƒ½ä¸ºå¼€å‘è€…æä¾›ä¸€è‡´çš„APIï¼Œå¹¶èƒ½å¤Ÿç¡®ä¿è½¬æ¢å™¨ä¹‹é—´èƒ½å¤ŸååŒè¿è¡Œã€‚ä¾‹å¦‚ï¼Œå¦‚æœè½¬æ¢å™¨(æˆ–ç¼–ç å™¨)çš„ç±»å‹ä¸€è‡´çš„è¯ï¼Œèƒ½å¤Ÿå°†ä»–ä»¬åˆå¹¶åˆ°ä¸€èµ·ï¼Œåˆå¹¶åçš„è½¬æ¢å™¨èƒ½å¤Ÿå½¢æˆå•ç‹¬çš„å•å…ƒã€‚æ­¤å¤–ï¼Œè¿™äº›åˆå¹¶åçš„è½¬æ¢å™¨ä½¿ç”¨èµ·æ¥æ¯”å•ç‹¬çš„è½¬æ¢å™¨æ›´æœ‰æ•ˆã€‚

### ç¼–è§£ç å™¨

ä¸€ä¸ªç¼–è§£ç å™¨ç»“åˆäº†ä¸¤ä¸ªè½¬æ¢å™¨ï¼Œä¸€ä¸ªç¼–ç å™¨ï¼Œä¸€ä¸ªè§£ç å™¨ã€‚

```dart
abstract class Codec<S, T> {
  const Codec();

  T encode(S input) => encoder.convert(input);
  S decode(T encoded) => decoder.convert(encoded);

  Converter<S, T> get encoder;
  Converter<T, S> get decoder;

  Codec<S, dynamic> fuse(Codec<T, dynamic> other) { .. }
  Codec<T, S> get inverted => ...;
}
```

å¦‚ä¸Šæ‰€ç¤ºï¼Œç¼–è§£ç å™¨æä¾›äº†æ–¹ä¾¿çš„æ–¹æ³•ï¼Œä¾‹å¦‚ç”¨ç¼–ç å™¨å’Œè§£ç å™¨è¡¨è¾¾çš„`encode()`å’Œ`decode()`ã€‚`fuse()`æ–¹æ³•å’Œ`inverted`å–å¾—æ–¹æ³•åˆ†åˆ«å…è®¸ä½ å»åˆå¹¶è½¬æ¢å™¨å’Œæ”¹å˜ç¼–ç çš„æ–¹å‘ã€‚ç¼–è§£ç å™¨çš„åŸºæœ¬å®ç°ï¼Œä¸ºè¿™ä¸¤ä¸ªæˆå‘˜æä¾›äº†å›ºå®šé»˜è®¤çš„å®ç°å’Œæˆå‘˜ï¼Œé€šå¸¸ä¸éœ€è¦æ‹…å¿ƒä»–ä»¬ã€‚

`encode()`å’Œ`decode()`æ–¹æ³•ä¹Ÿå¯ä»¥ä¸ç”¨åŠ¨ï¼Œä½†æ˜¯ä»–ä»¬å¯ä»¥æ·»åŠ æ–°çš„å‚æ•°ã€‚ä¾‹å¦‚ï¼Œ`JsonCodec`å‘`encode()`å’Œ`decode()`è¿½åŠ äº†å‘½åå‚æ•°æ¥è®©ä»–ä»¬çš„æ–¹æ³•æ›´æœ‰ç”¨ï¼š

```dart
dynamic decode(String source, {reviver(var key, var value)}) { â€¦ }
String encode(Object value, {toEncodable(var object)}) { â€¦ }
```

è¿™ä¸ªç¼–è§£ç å™¨å¯ä»¥ä½¿ç”¨é»˜è®¤å‚æ•°è¿›è¡Œå®ä¾‹åŒ–ï¼Œé™¤éåœ¨è°ƒç”¨`encode()`/`decode()`æœŸé—´ï¼Œè¢«å‘½åå‚æ•°è¦†ç›–ã€‚

```dart
const JsonCodec({reviver(var key, var value), toEncodable(var object)})
  ...
```

å¸¸è§„ï¼šå¦‚æœç¼–è§£ç å™¨èƒ½å¤Ÿè¢«ç¡®è®¤ï¼Œä»–åº”è¯¥å‘`encode()`/`decode()`æ–¹æ³•è¿½åŠ å‘½åå‚æ•°ï¼Œå¹¶å…è®¸ä»–ä»¬åœ¨æ„é€ æ—¶è®¾ä¸ºé»˜è®¤å€¼ã€‚å¦‚æœå¯èƒ½ï¼Œç¼–è§£ç å™¨åº”è¯¥æ˜¯`const`ç±»å‹çš„æ„é€ å‡½æ•°ã€‚

### Converter

è½¬æ¢å™¨ï¼Œå°¤å…¶æ˜¯ä»–ä»¬çš„`convert()`æ–¹æ³•ï¼Œæ˜¯çœŸæ­£è½¬æ¢å‘ç”Ÿçš„åœ°æ–¹ã€‚

```dart
T convert(S input);  // where T is the target and S the source type.
```

æœ€å°è½¬æ¢å™¨åªéœ€è¦ç»§æ‰¿`Convert`ç±»ï¼Œå®ç°`convert()`æ–¹æ³•ã€‚ä¸ç¼–è§£ç å™¨ç±»ä¼¼ï¼Œè½¬æ¢å™¨èƒ½å¤Ÿé€šè¿‡ç»§æ‰¿æ„é€ å‡½æ•°å’Œè¿½åŠ å‘½åå‚æ•°åˆ°`convert()`æ–¹æ³•è¿›è¡Œé…ç½®ã€‚

è¿™ç§æœ€å°è½¬æ¢å™¨è¿è¡Œåœ¨åŒæ­¥è®¾ç½®ä¸­ï¼Œä¸èƒ½åœ¨å—(åŒæ­¥æˆ–å¼‚æ­¥)ç¯å¢ƒä¸­è¿è¡Œã€‚å°¤å…¶æ˜¯ï¼Œè¿™ç§ç®€å•çš„è½¬æ¢å™¨ä¸èƒ½ç”¨ä½œå˜å½¢å™¨(ä¸€ç§æ›´å¥½çš„è½¬æ¢å™¨ç‰¹æ€§)ã€‚ä¸€ä¸ªå®Œå…¨å®ç°çš„è½¬æ¢å™¨å®ç°äº†`SteamTransformer`æ¥å£ï¼Œä»è€Œèƒ½å¤Ÿæœ‰`Steam.transform()`æ–¹æ³•ã€‚

å¯èƒ½æœ€å¸¸ç”¨çš„ç”¨ä¾‹æ˜¯ä½¿ç”¨`UTF8.decoder`è¿›è¡ŒUTF-8è§£ç 

```dart
File.openRead().transform(UTF8.decoder).
```

### åˆ†å—è½¬æ¢

åˆ†å—è½¬æ¢çš„æ¦‚å¿µä»¤äººå›°æƒ‘ï¼Œä½†æ˜¯ä»å®ƒçš„æ ¸å¿ƒæ¥çœ‹ï¼Œå®ƒä¹Ÿæ˜¯ç›¸å¯¹ç®€å•çš„ã€‚å½“åˆ†å—è½¬æ¢(åŒ…æ‹¬æµè½¬æ¢)å¼€å§‹æ—¶ï¼Œè½¬æ¢å™¨çš„`startChunkedConversion`æ–¹æ³•å°†ä¼šä½¿ç”¨è¾“å‡ºæ¥æ”¶å™¨ä½œä¸ºå‚æ•°è¿›è¡Œè°ƒç”¨ã€‚ç„¶åè¿™ä¸ªæ–¹æ³•å°†ä¼šè¿”å›ä¸€ä¸ªè®©è°ƒç”¨è€…æ”¾æ•°æ®çš„è¾“å…¥æ¥æ”¶å™¨ã€‚

![chunked-conversion.png](/assets/img/chunked-conversion.png)

__æç¤º__ï¼šå›¾ä¸­å¸¦æ˜Ÿå·çš„è¡¨ç¤ºå¤šæ¬¡è°ƒç”¨ã€‚

å›¾ä¸­ï¼Œç¬¬ä¸€æ­¥åˆ›å»ºä¸€ä¸ªå¡«å……è¦è½¬æ¢æ•°æ®çš„`outputSink`ã€‚ç„¶åç”¨æˆ·è°ƒç”¨å¸¦æœ‰è¾“å‡ºæ¥æ”¶å™¨çš„è½¬æ¢å™¨çš„`startChunkedConversion()`æ–¹æ³•ã€‚ç»“æœæ˜¯å¸¦æœ‰`add()`å’Œ`close()`æ–¹æ³•çš„è¾“å…¥æ¥å—å™¨ã€‚

ä¸‹ä¸€ä¸ªç‚¹ï¼Œä»£ç å°†ä¼šå¼€å§‹åˆ†å—è½¬æ¢è°ƒç”¨ï¼Œå¯èƒ½å‘ç”Ÿå¤šæ¬¡ï¼Œ`add()`æ–¹æ³•ä¼šæºå¸¦æ•°æ®ã€‚æ•°æ®ä¼šè¢«è¾“å…¥æ¥æ”¶å™¨è½¬æ¢ã€‚å¦‚æœè½¬æ¢çš„æ•°æ®å·²ç»å‡†å¤‡å¥½äº†ï¼Œè¾“å…¥æ¥æ”¶å™¨ä¼šæŠŠå®ƒå‘é€åˆ°è¾“å‡ºæ¥æ”¶å™¨ï¼Œå¯èƒ½`add()`æ–¹æ³•ä¼šè¢«è°ƒç”¨å¤šæ¬¡ã€‚æœ€ç»ˆç”¨æˆ·ä¼šé€šè¿‡è°ƒç”¨`close()`ç»“æŸè½¬æ¢ã€‚åœ¨è¿™ä¸ªç‚¹ä¸Šï¼Œä»»ä½•ä¿å­˜çš„è½¬æ¢åçš„æ•°æ®ä¼šä»è¾“å…¥æ¥æ”¶å™¨å‘é€åˆ°è¾“å‡ºæ¥æ”¶å™¨ï¼Œå¹¶ä¸”è¾“å‡ºæ¥æ”¶å™¨ä¼šè¢«å…³é—­ã€‚

åŸºäºè½¬æ¢å™¨çš„è¾“å…¥æ¥æ”¶å™¨å¯èƒ½éœ€è¦ç¼“å­˜è¾“å…¥æ•°æ®çš„éƒ¨åˆ†ã€‚ä¾‹å¦‚ï¼Œè¡Œåˆ†å‰²å™¨æ¥å—`ab\ncd`ä½œä¸ºå—ï¼Œèƒ½å¤Ÿå®‰å…¨çš„è°ƒç”¨å«æœ‰`ab`çš„è¾“å‡ºæ¥æ”¶å™¨ï¼Œä½†æ˜¯éœ€è¦ç­‰å¾…ä¸‹ä¸€ä¸ªæ•°æ®(æˆ–è€…)ã€‚å¦‚æœä¸‹ä¸€ä¸ªæ•°æ®æ˜¯`e\nf`ï¼Œè¾“å…¥æ¥æ”¶å™¨å¿…é¡»ä¸²è”`cd`å’Œ`e`å¹¶ä¸”è°ƒç”¨å¸¦æœ‰`cde`çš„è¾“å‡ºæ¥æ”¶å™¨ï¼ŒåŒæ—¶ç¼“å­˜`f`ä½œä¸ºä¸‹ä¸€ä¸ªæ•°æ®çš„äº‹ä»¶(æˆ–è€…è°ƒç”¨`close`)ã€‚

æœ‰è¶£çš„æ˜¯ï¼Œåˆ†å—è½¬æ¢çš„ç±»å‹ä¸èƒ½ä»å®ƒåŒæ­¥è½¬æ¢ä¸­è¯†åˆ«å‡ºæ¥ã€‚ä¾‹å¦‚ï¼Œ`HtmlEscape`è½¬æ¢å™¨åŒæ­¥è½¬æ¢å­—ç¬¦ä¸²åˆ°å­—ç¬¦ä¸²ï¼Œå’ŒåŒæ­¥è½¬æ¢å­—ç¬¦å—åˆ°å­—ç¬¦å—(å­—ç¬¦ä¸²åˆ°å­—ç¬¦ä¸²)ã€‚è¡Œåˆ†å‰²å™¨åŒæ­¥è½¬æ¢å­—ç¬¦ä¸²åˆ°åˆ—è¡¨(åˆ†å‰²åçš„è¡Œ).å°½ç®¡åŒæ­¥çš„ç­¾åä¸åŒï¼Œè¡Œåˆ†å‰²å™¨çš„å—ç‰ˆæœ¬ä¸HtmlEscapeæœ‰ç›¸åŒçš„ç­¾åï¼šStringâ†’Stringã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼Œæ¯ä¸ªåˆ†å‰²å‡ºæ¥çš„å—éƒ½æ˜¯ä¸€è¡Œã€‚

```dart
import 'dart:convert';
import 'dart:async';

main() async {
  // HtmlEscape synchronously converts Strings to Strings.
  print(const HtmlEscape().convert("foo")); // "foo".
  // When used in a chunked way it converts from Strings
  // to Strings.
  var stream = new Stream.fromIterable(["f", "o", "o"]);
  print(await (stream.transform(const HtmlEscape())
                     .toList()));    // ["f", "o", "o"].

  // LineSplitter synchronously converts Strings to Lists of String.
  print(const LineSplitter().convert("foo\nbar")); // ["foo", "bar"]
  // However, asynchronously it converts from Strings to Strings (and
  // not Lists of Strings).
  var stream2 = new Stream.fromIterable(["fo", "o\nb", "ar"]);
  print("${await (stream2.transform(const LineSplitter())
                          .toList())}");
}
```

é€šå¸¸æ¥è¯´ï¼Œå½“æŒ‰ç…§StreamTransformerè¿›è¡Œä½¿ç”¨æ—¶ï¼Œåˆ†å—è½¬æ¢çš„ç±»å‹ç”±æœ€æœ‰ç”¨çš„ç”¨ä¾‹å†³å®šã€‚

### åˆ†å—è½¬æ¢æ¥æ”¶å™¨

`ChunkedConversionSink`æ˜¯ç”¨æ¥å‘è½¬æ¢å™¨è¿½åŠ æ•°æ®æˆ–è€…ä½œä¸ºè½¬æ¢å™¨çš„è¾“å‡ºã€‚æœ€åŸºæœ¬çš„åˆ†å—è½¬æ¢æ¥æ”¶å™¨æœ‰ä¸¤ä¸ªæ–¹æ³•ï¼š`add()`å’Œ`close()`ã€‚åœ¨æ‰€æœ‰çš„ç³»ç»Ÿæ¥æ”¶å™¨é‡Œä¾‹å¦‚`StringSinks`æˆ–`StreamSinks`éƒ½æœ‰ç›¸åŒçš„åŠŸèƒ½ã€‚

åˆ†å—è½¬æ¢æ¥æ”¶å™¨çš„è¯­ä¹‰ç±»ä¼¼äº`IOSinks`ï¼šæ•°æ®æ·»åŠ åˆ°æ¥æ”¶å™¨ä¹‹åå¿…é¡»ä¸èƒ½ç¼–è¾‘ï¼Œé™¤éå¯ä»¥ä¿è¯æ•°æ®å·²è¢«å¤„ç†ã€‚å¯¹äºå­—ç¬¦ä¸²æ˜¯æ²¡æœ‰é—®é¢˜çš„(å› ä¸ºä»–ä»¬æ˜¯ä¸å¯æ”¹å˜çš„)ï¼Œä½†æ˜¯å¯¹äºå­—èŠ‚åˆ—è¡¨ï¼Œå®ƒç»å¸¸æ„å‘³ç€ç”³è¯·ä¸€å—åˆ—è¡¨çš„å¤‡ä»½ã€‚è¿™å¯èƒ½æ˜¯ä½æ•ˆçš„ï¼Œ`dart:convert`åº“é™„å¸¦äº†åˆ†å—è½¬æ¢å™¨çš„å­ç±»æ”¯æŒæ›´æœ‰æ•ˆçš„æ•°æ®ä¼ è¾“ã€‚

ä¾‹å¦‚ï¼Œ`ByteConversionSink`æœ‰é¢å¤–çš„æ–¹æ³•

```dart
addSlice(List<int> chunk, int start, int end, bool isLast)
```

ä»è¯­ä¹‰ä¸Šæ¥è®²ï¼Œå®ƒæ¥å—ä¸€ä¸ªåˆ—è¡¨(å¯èƒ½ä¸ä¼šä¿å­˜),è½¬æ¢å™¨èƒ½å¤Ÿæ“ä½œçš„å­èŒƒå›´ï¼Œå’Œä¸€ä¸ªå¯ä»¥ä»£æ›¿`close()`çš„boolå‹çš„`isLast`ã€‚

```dart
import 'dart:convert';

main() {
  var outSink = new ChunkedConversionSink.withCallback((chunks) {
    print(chunks.single); // ğ…¡
  });

  var inSink = UTF8.decoder.startChunkedConversion(outSink);
  var list = [0xF0, 0x9D];
  inSink.addSlice(list, 0, 2, false);
  // Since we used `addSlice` we are allowed to reuse the list.
  list[0] = 0x85;
  list[1] = 0xA1;
  inSink.addSlice(list, 0, 2, true);
}
```

ä½œä¸ºåˆ†å—è½¬æ¢æ¥æ”¶å™¨çš„ä½¿ç”¨è€…(å®ƒæ—¢å¯ä»¥è¾“å…¥å’Œè¾“å‡ºè½¬æ¢å™¨)ï¼Œå®ƒæä¾›äº†æ›´å¤šçš„é€‰æ‹©ã€‚äº‹å®ä¸Šï¼Œåˆ—è¡¨ä¸ä¼šè¢«ä¿å­˜ï¼Œæ„å‘³ç€ä½ å¯ä»¥ä½¿ç”¨ç¼“å­˜å¹¶æ¯æ¬¡è°ƒç”¨æ—¶é‡ç”¨è¯¥ç¼“å­˜ã€‚æ‹¼æ¥`add()`å’Œ`close()`å¯ä»¥å¸®åŠ©æ¥æ”¶å™¨é¿å…ç¼“å­˜æ•°æ®ã€‚æ¥æ”¶å­—åˆ—è¡¨é¿å…å¯¹`SubList()`çš„è°ƒç”¨(å¤åˆ¶æ•°æ®)ã€‚

è¯¥æ¥å£çš„ç¼ºç‚¹æ˜¯å®ç°èµ·æ¥å¤æ‚ã€‚ä¸ºäº†å‡è½»å¼€å‘äººå‘˜çš„ç—›è‹¦ï¼Œæ¯ä¸ªæ”¹è¿›çš„`dart:convert`åˆ†å—è½¬æ¢æ¥æ”¶å™¨éƒ½æœ‰ä¸€ä¸ªåŸºç±»ï¼Œå®ƒå®ç°äº†é™¤äº†ä¸€ä¸ªæ–¹æ³•(æŠ½è±¡æ–¹æ³•)ä¹‹å¤–çš„æ‰€æœ‰æ–¹æ³•ã€‚ç„¶åï¼Œè½¬æ¢æ¥æ”¶å™¨çš„å®ç°è€…èƒ½å¤Ÿå†³å®šæ˜¯å¦åˆ©ç”¨å…¶å®ƒæ–¹æ³•ã€‚

æ³¨æ„ï¼šåˆ†å—è½¬æ¢æ¥æ”¶å™¨ __å¿…é¡»__ æ‰©å±•ç›¸åº”çš„åŸºç±»ã€‚è¿™ç¡®ä¿äº†å‘ç°æœ‰çš„æ¥æ”¶å™¨æ¥å£æ·»åŠ åŠŸèƒ½è€Œä¸ä¼šç ´åæ‰©å±•æ¥æ”¶å™¨ã€‚

### ä¾‹å­

æœ¬èŠ‚ä»‹ç»åˆ›å»ºç®€å•åŠ å¯†è½¬æ¢å™¨çš„æ‰€æœ‰æ­¥éª¤ï¼Œä»¥åŠæ€æ ·æé«˜è‡ªå®šä¹‰åˆ†å—è½¬æ¢å™¨çš„æ•ˆç‡ã€‚

è®©æˆ‘ä»¬ä»ç®€å•çš„åŒæ­¥è½¬æ¢å™¨å¼€å§‹ï¼Œå…¶åŠ å¯†å†ç¨‹åªæ˜¯ç®€å•çš„æŒ‰ç…§ç»™å®šçš„å€¼æ—‹è½¬å­—èŠ‚ï¼š

```dart
import 'dart:convert';

/// A simple extension of Rot13 to bytes and a key.
class RotConverter extends Converter<List<int>, List<int>> {
  final _key;
  const RotConverter(this._key);

  List<int> convert(List<int> data, { int key }) {
    if (key == null) key = this._key;
    var result = new List<int>(data.length);
    for (int i = 0; i < data.length; i++) {
      result[i] = (data[i] + key) % 256;
    }
    return result;
  }
}
```

ç›¸åº”çš„ç¼–è§£ç ç±»ä¹Ÿæ˜¯å¾ˆç®€å•ï¼š

```dart
class Rot extends Codec<List<int>, List<int>> {
  final _key;
  const Rot(this._key);

  List<int> encode(List<int> data, { int key }) {
    if (key == null) key = this._key;
    return new RotConverter(key).convert(data);
  }

  List<int> decode(List<int> data, { int key }) {
    if (key == null) key = this._key;
    return new RotConverter(-key).convert(data);
  }

  RotConverter get encoder => new RotConverter(_key);
  RotConverter get decoder => new RotConverter(-_key);
}
```

æˆ‘ä»¬èƒ½å¤Ÿ(ä¹Ÿåº”è¯¥)é¿å…`æ–°çš„`å†…å­˜ç”³è¯·ï¼Œä½†æ˜¯ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬æ¯æ¬¡éœ€è¦æ—¶æˆ‘ä»¬éƒ½ä¼šç”³è¯·æ–°çš„`RotConverter`å¥æŸ„ã€‚

è¿™é‡Œæ˜¯æˆ‘ä»¬æ€æ ·ä½¿ç”¨Rotç¼–è§£ç å™¨ï¼š

```dart
const Rot ROT128 = const Rot(128);
const Rot ROT1 = const Rot(1);
main() {

  print(const RotConverter(128).convert([0, 128, 255, 1]));   // [128, 0, 127, 129]
  print(const RotConverter(128).convert([128, 0, 127, 129])); // [0, 128, 255, 1]
  print(const RotConverter(-128).convert([128, 0, 127, 129]));// [0, 128, 255, 1]

  print(ROT1.decode(ROT1.encode([0, 128, 255, 1])));          // [0, 128, 255, 1]
  print(ROT128.decode(ROT128.encode([0, 128, 255, 1])));      // [0, 128, 255, 1]
}
```

æˆ‘ä»¬åšçš„æŒºå¯¹çš„ã€‚ç¼–è§£ç å™¨è¿è¡Œæ­£å¸¸ï¼Œä½†æ˜¯å®ƒè¿˜ç¼ºå°‘åˆ†å—ç¼–ç éƒ¨åˆ†ã€‚å› ä¸ºæ¯ä¸€å­—èŠ‚çš„ç¼–ç éƒ½æ˜¯åˆ†ç¦»çš„ï¼Œæˆ‘ä»¬å›åˆ°åŒæ­¥ä¸è½¬æ¢æ–¹æ³•ï¼š

```dart
class RotConverter {
  ...
  RotSink startChunkedConversion(sink) {
    return new RotSink(_key, sink);
  }
}

class RotSink extends ChunkedConversionSink<List<int>> {
  final _converter;
  final ChunkedConversionSink<List<int>> _outSink;
  RotSink(key, this._outSink) : _converter = new RotConverter(key);

  void add(List<int> data) {
    _outSink.add(_converter.convert(data));
  }

  void close() {
    _outSink.close();
  }
}
```

ç°åœ¨æˆ‘ä»¬å¯ä»¥ä½¿ç”¨è½¬æ¢å™¨è¿›è¡Œåˆ†å—è½¬æ¢æˆ–è€…æµè½¬æ¢ï¼š

```dart
// Requires to import dart:io.
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  new File(inFile)
    .openRead()
    .transform(new RotConverter(key))
    .pipe(new File(outFile).openWrite());
}
```

### ç‰¹æ®Šçš„åˆ†å—è½¬æ¢æ¥æ”¶å™¨

å‡ºäºå¾ˆå¤šåŸå› ï¼Œå½“å‰ç‰ˆæœ¬çš„Rotå°±è¶³å¤Ÿäº†ã€‚ä¹Ÿå°±æ˜¯è¯´ï¼Œå¤æ‚ä»£ç å’Œæµ‹è¯•è¦æ±‚çš„æˆæœ¬å°†è¶…è¿‡æ”¹è¿›çš„æ”¶ç›Šã€‚ä½†æ˜¯ï¼Œæˆ‘ä»¬å‡è®¾è½¬æ¢å™¨çš„æ€§èƒ½è‡³å…³é‡è¦(å®ƒåœ¨ç¹å¿™è·¯å¾„å’Œé…ç½®æ–‡ä»¶ä¸­)ã€‚æˆ‘ä»¬è¿›ä¸€æ­¥å‡è®¾ä¸ºæ¯ä¸€å—åˆ—è¡¨å¿«åˆ†é…å†…å­˜å°†ä¼šä½¿æ€§èƒ½å´©æºƒ(åˆç†çš„å‡è®¾)ã€‚

é¦–å…ˆï¼Œæˆ‘ä»¬æ˜¯å†…å­˜æ¶ˆè€—æ›´å°‘ï¼šä½¿ç”¨`typed byte-list`ï¼Œæˆ‘ä»¬èƒ½å¤Ÿå‡å°‘åˆ†æ‰¹ç»™åˆ—è¡¨çš„å†…å­˜8å€å¤§å°(åœ¨64ä½æœºå™¨ä¸Š)ã€‚è¿™æ ·åšè™½ç„¶ä¸èƒ½å»æ‰å†…å­˜åˆ†é…ï¼Œä½†æ˜¯ä¼šè®©å®ƒåˆ†é…çš„æ›´å°‘ã€‚

æˆ‘ä»¬å¯ä»¥é¿å…åˆ†é…å†…å­˜ï¼Œå¦‚æœæˆ‘ä»¬èƒ½å¤Ÿé‡å†™è¾“å…¥ã€‚åœ¨ä¸‹ä¸€ä¸ªç‰ˆæœ¬çš„RotSink,æˆ‘ä»¬åŠ äº†ä¸€ä¸ª`addModifiable()`æ–¹æ³•ï¼Œå¦‚ä¸‹æ‰€ç¤ºï¼š

```dart
class RotSink extends ChunkedConversionSink<List<int>> {
  final _key;
  final ChunkedConversionSink<List<int>> _outSink;
  RotSink(this._key, this._outSink);

  void add(List<int> data) {
    addModifiable(new Uint8List.fromList(data));
  }

  void addModifiable(List<int> data) {
    for (int i = 0; i < data.length; i++) {
      data[i] = (data[i] + _key) % 256;
    }
    _outSink.add(data);
  }

  void close() {
    _outSink.close();
  }
}
```

ä¸ºäº†ç®€å•èµ·è§ï¼Œæˆ‘ä»¬è¿½åŠ äº†ä¸€ä¸ªæ¶ˆè€—å®Œæ•´åˆ—è¡¨çš„æ–°æ–¹æ³•ã€‚ä¸€ä¸ªæ›´é«˜çº§çš„æ–¹æ³•(ä¾‹å¦‚ï¼Œ`addModifiableSliece()`)ä¼šæºå¸¦èŒƒå›´å‚æ•°(`from`, `to`)å’Œä¸€ä¸ªbooleançš„`isLast`æœ€ä¸ºå‚æ•°ã€‚

è¿™æ˜¯ä¸€ä¸ªæ–°çš„æ–¹æ³•è¿˜æ²¡æœ‰è¢«å˜æ¢å™¨ä½¿ç”¨ï¼Œä½†æ˜¯æˆ‘ä»¬å·²ç»èƒ½å¤Ÿæ˜¾ç¤ºçš„é€šè¿‡è°ƒç”¨`startChunkedConversion`è¿›è¡Œä½¿ç”¨ã€‚

```dart
main() {
  var outSink = new ChunkedConversionSink.withCallback((chunks) {
    print(chunks); // [[31, 32, 33], [24, 25, 26]]
  });
  var inSink = new RotConverter(30).startChunkedConversion(outSink);
  inSink.addModifiable([1, 2, 3]);
  inSink.addModifiable([250, 251, 252]);
  inSink.close();
}
```

åœ¨è¿™ä¸ªå°ä¾‹å­ä¸­ï¼Œæ€§èƒ½æ²¡æœ‰æ˜æ˜¾ä¸åŒï¼Œä½†æ˜¯åœ¨å†…éƒ¨ï¼Œåˆ†å—è½¬æ¢é¿å…äº†ä¸ºå„ä¸ªå—åˆ†é…æ–°åˆ—è¡¨ã€‚å¯¹äºä¸¤ä¸ªå°å—ï¼Œä»–æ²¡æœ‰ä»€ä¹ˆåŒºåˆ«ï¼Œä½†å¦‚æœæˆ‘ä»¬ä¸ºæµè½¬æ¢å™¨å®ç°äº†è¿™ç‚¹ï¼ŒåŠ å¯†å¤§çš„æ–‡ä»¶å°±èƒ½æ›´å¿«ã€‚

ä¸ºæ­¤ï¼Œæˆ‘ä»¬å¯ä»¥åˆ©ç”¨IOStreamæä¾›çš„å¯ä¿®æ”¹åˆ—è¡¨çš„æœªè®°å½•åŠŸèƒ½ã€‚ç°åœ¨ï¼Œæˆ‘ä»¬å¯ä»¥ç®€å•çš„é‡å†™`add()`å¹¶æŠŠå®ƒæŒ‡å‘`addModifiable()`.é€šå¸¸ï¼Œè¿™æ˜¯ä¸å®‰å…¨çš„ï¼Œå¹¶ä¸”è¿™æ ·çš„è½¬æ¢å™¨å°†ä¼šæˆä¸ºéš¾ä»¥è¿½è¸ªé”™è¯¯çš„æ¥æºã€‚ç›¸åï¼Œæˆ‘ä»¬å†™ä¸€ä¸ªè½¬æ¢å™¨ï¼Œæ˜ç¡®çš„è¿›è¡Œä¸å¯ä¿®æ”¹åˆ°å¯ä¿®æ”¹çš„è½¬æ¢ï¼Œç„¶åèåˆä¸¤ä¸ªè½¬æ¢å™¨ã€‚

```dart
class ToModifiableConverter extends Converter<List<int>, List<int>> {
  List<int> convert(List<int> data) => data;
  ToModifiableSink startChunkedConversion(RotSink sink) {
    return new ToModifiableSink(sink);
  }
}

class ToModifiableSink
    extends ChunkedConversionSink<List<int>, List<int>> {
  final RotSink sink;
  ToModifiableSink(this.sink);

  void add(List<int> data) { sink.addModifiable(data); }
  void close() { sink.close(); }
}
```

`ToModifiableSink`åªæ˜¯å‘ä¸‹ä¸€ä¸ªæ¥æ”¶å™¨å‘é€ä¿¡å·ï¼Œè¡¨æ˜ä¼ å…¥çš„å—å¯ä»¥ä¿®æ”¹ã€‚æˆ‘ä»¬èƒ½å¤Ÿä½¿ç”¨å®ƒæ¥æé«˜æˆ‘ä»¬çš„ç®¡é“æ•ˆç‡ã€‚

```dart
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  new File(inFile)
      .openRead()
      .transform(
          new ToModifiableConverter().fuse(new RotConverter(key)))
      .pipe(new File(outFile).openWrite());
}
```

åœ¨æˆ‘çš„æœºå™¨ä¸Šï¼Œè¿™ä¸ªå°ä¿®æ”¹å°†11MBæ–‡ä»¶çš„åŠ å¯†æ—¶é—´ä»450msé™ä½åˆ°260msã€‚æˆ‘ä»¬å®ç°äº†è¿™ç§åŠ é€Ÿï¼Œæ²¡æœ‰ä¸¢å¤±ç°æœ‰ç¼–ç å™¨çš„å…¼å®¹æ€§(å…³äº`fuse()`æ–¹æ³•)ï¼Œå¹¶ä¸”è½¬æ¢å™¨å§‹ç»ˆæ˜¯æµè½¬æ¢å™¨ã€‚

é‡ç”¨è¾“å…¥å¯ä»¥å¾ˆå¥½åœ°ä¸å…¶ä»–è½¬æ¢å™¨é…åˆä½¿ç”¨ï¼Œè€Œä¸ä»…ä»…æ˜¯é€‚ç”¨æˆ‘ä»¬çš„Rotå¯†ç ã€‚å› æ­¤ï¼Œæˆ‘ä»¬åº”è¯¥åˆ›å»ºä¸€ä¸ªæ¦‚æ‹¬æ¦‚å¿µçš„æ¥å£ã€‚ç®€å•èµ·è§ï¼Œæˆ‘ä»¬å°†å®ƒå‘½åä¸ºCipherSink
ï¼Œå½“ç„¶å®ƒå¯ä»¥åœ¨åŠ å¯†ä¸–ç•Œä¹‹å¤–ä½¿ç”¨ã€‚

```dart
abstract class CipherSink
    extends ChunkedConversionSink<List<int>, List<int>> {
  void addModifiable(List<int> data) { add(data); }
}
```

æˆ‘ä»¬å¯ä»¥æ˜¯æˆ‘ä»¬çš„RotSinkç§æœ‰ï¼Œå¹¶æŠŠCipherSinkæš´éœ²å‡ºå»ã€‚å…¶å®ƒçš„å¼€å‘è€…å¯ä»¥é‡ç”¨æˆ‘ä»¬çš„å·¥ä½œ(CipherSinkå’ŒToModifiableConverter)å¹¶ä»ä¸­å—ç›Šã€‚

ä½†æ˜¯æˆ‘ä»¬è¿˜æ²¡å®Œäº‹å‘¢ã€‚

å°½ç®¡æˆ‘ä»¬ä¸èƒ½æ˜¯åŠ å¯†æ›´å¿«äº†ï¼Œæˆ‘ä»¬å¯ä»¥æé«˜Rotè½¬æ¢å™¨çš„è¾“å‡ºç«¯ã€‚ä¾‹å¦‚ï¼Œèåˆä¸¤ç§åŠ å¯†æ–¹å¼ï¼š

```dart
main(args) {
  String inFile = args[0];
  String outFile = args[1];
  int key = int.parse(args[2]);
  // Double-strength cipher running the Rot-cipher twice.
  var transformer = new ToModifiableConverter()
       .fuse(new RotConverter(key))  // <= fused RotConverters.
       .fuse(new RotConverter(key));
  new File(inFile)
      .openRead()
      .transform(transformer)
      .pipe(new File(outFile).openWrite());
}
```

ç”±äºç¬¬ä¸€ä¸ªRotConverterè°ƒç”¨äº†`outSink.add()`,å‡å¦‚ç¬¬äºŒä¸ªRotConverterè¾“å…¥ä¸èƒ½è¢«ç¼–è¾‘å’Œå¤åˆ¶æ•°æ®ã€‚æˆ‘ä»¬å¯ä»¥åœ¨ä¸¤ä¸ªåŠ å¯†ä¹‹é—´æ’å…¥`ToModifiableConverter`æ¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼š

```dart
var transformer = new ToModifiableConverter()
       .fuse(new RotConverter(key))
       .fuse(new ToModifiableConverter())
       .fuse(new RotConverter(key));
```

è¿™æœ‰ç”¨ï¼Œä½†æ˜¯å¤ªå‚»ã€‚æˆ‘ä»¬å¸Œæœ›RotConverteråœ¨æ²¡æœ‰ä¸­é—´è½¬æ¢å™¨çš„æƒ…å†µä¸‹è¿›è¡Œè¿è¡Œã€‚ç¬¬ä¸€ä¸ªå¯†ç åº”è¯¥æŸ¥çœ‹ä»–çš„è¾“å‡ºæ¥æ”¶å™¨å¹¶ç¡®å®šä»–æ˜¯å¦æ˜¯CipherSinkã€‚æ— è®ºä½•æ—¶æˆ‘ä»¬æƒ³æ·»åŠ æ–°å—æˆ–è€…åœ¨æˆ‘ä»¬å¼€å§‹åˆ†å—è½¬æ¢æ—¶ï¼Œæˆ‘ä»¬éƒ½å¯ä»¥è¿™ä¹ˆåšã€‚æˆ‘ä»¬æ›´å–œæ¬¢åä¸€ç§æ–¹æ³•ï¼š

```dart
 /// Works more efficiently if given a CipherSink as argument.
  CipherSink startChunkedConversion(
      ChunkedConversionSink<List<int>> sink) {
    if (sink is! CipherSink) sink = new _CipherSinkAdapter(sink);
    return new _RotSink(_key, sink);
  }
```

_CipherSinkAdapterå¾ˆç®€å•ï¼š

```dart
class _CipherSinkAdapter implements CipherSink {
  ChunkedConversionSink<List<int>, List<int>> sink;
  _CipherSinkAdapter(this.sink);

  void add(data) { sink.add(data); }
  void addModifiable(data) { sink.add(data); }
  void close() { sink.close(); }
}
```

æˆ‘ä»¬ç°åœ¨åªéœ€è¦æ›´æ”¹_RotSinkä»¥åˆ©ç”¨å®ƒå§‹ç»ˆæ¥æ”¶CipherSinkä½œä¸ºå…¶æ„é€ å‡½æ•°çš„å‚æ•°è¿™ä¸€äº‹å®ï¼š

```dart
class _RotSink extends CipherSink {
  final _key;
  final CipherSink _outSink;  // <= always a CipherSink.
  _RotSink(this._key, this._outSink);

  void add(List<int> data) {
    addModifiable(data.toList());
  }

  void addModifiable(List<int> data) {
    for (int i = 0; i < data.length; i++) {
      data[i] = (data[i] + _key) % 256;
    }
    _outSink.addModifiable(data);  // <= safe to call addModifiable.
  }

  void close() {
    _outSink.close();
  }
}
```

é€šè¿‡è¿™äº›æ›´æ”¹ï¼Œæˆ‘ä»¬çš„è¶…çº§å®‰å…¨åŒå¯†ç å°†ä¸ä¼šåˆ†é…ä»»ä½•æ–°åˆ—è¡¨ï¼Œæˆ‘ä»¬çš„å·¥ä½œä¹Ÿå·²å®Œæˆã€‚

æœç„¶å¤Ÿéš¾ï¼Œå¤Ÿå¤æ‚ã€‚